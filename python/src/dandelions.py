# -*- coding: utf-8 -*-
"""dandelions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IWUKPTU-4vkNLIQ1g71r7MsfJfPk5C4P
"""

!pip install roboflow
!pip install ultralytics
from ultralytics import YOLO
'''from roboflow import Roboflow
rf = Roboflow(api_key="r4ammRUrSQtQPTTjPgVq")
project = rf.workspace("plantstesting").project("violet-test")
version = project.version(1)
dataset = version.download("multiclass")
model = YOLO("yolo11n.pt")
!pip install roboflow'''
from roboflow import Roboflow
'''rf = Roboflow(api_key="r4ammRUrSQtQPTTjPgVq")
project = rf.workspace("plantstesting").project("poisonplant1")'''

rf = Roboflow(api_key="r4ammRUrSQtQPTTjPgVq")
project = rf.workspace("plantstesting").project("dandelion-yellow")
version = project.version(2)
dataset = version.download("yolov11")
model = YOLO()
dataset = version.download("yolov11")

!unzip runs/detect/train13.zip -d runs/detect/train13

model2 = YOLO("/content/yolo11n.pt")
results = model.train(data="/content/Dandelion-(Yellow)-2/data.yaml", epochs=2,imgsz=256,save=True,save_period=1)

results = model(source="/content/Dandelion-(Yellow)-2/train/images",conf=0.012,iou=0.05)#Add your own image
for result in results:
    result.show()
    #print((int)(results.boxes.xywh[0,0]))
# for orig_img in results:
        #class_id, x_center, y_center, w, h = orig_img

from ultralytics import YOLO
import cv2
import numpy as np
from google.colab.patches import cv2_imshow # Import cv2_imshow

colors = {
    'red': ([0, 50, 50], [10, 255, 255]),  # Dirt
    'brown': ([10, 35, 50], [45, 255, 255]),  # Dead leaves/grass (Adjusted)
    'green': ([35, 80, 20], [55, 255, 255]),  # Grass/greenery (Adjusted)
    'purple': ([120, 50, 30], [160, 255, 255]),  # Purple flowers
    'yellow': ([20, 100, 100], [30, 255, 255]),  # Yellow flowers
    'white': ([0, 0, 150], [180, 50, 255])  # Snow
}

# This method is used to detect the colors of each plant
def detect_colors(image_path, overlap=True):
    """
    Detects colors in an image using YOLO and displays the results.

    Args:
        image_path (str): The path to the input image.
        overlap (bool): Whether to allow overlapping colors.
    """
    img = cv2.imread(image_path)
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    #hsv uses hue, saturation, and brightness

    color_masks = {} # Empty dictionary to store color masks


    # Convert the image to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Apply adaptive thresholding
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 11, 2)

    # Find contours of white regions. This is used in detecting snow and other white things in images.
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw contours on the original image (or process as needed)
    cv2.drawContours(img, contours, -1, (255, 255, 255), 2)
    for color_name, (lower, upper) in colors.items():
        mask = cv2.inRange(hsv, np.array(lower), np.array(upper))
        color_masks[color_name] = mask


        # Overlapping colors: simply display the masks on the original image
    for color_name, mask in color_masks.items():
        img[mask > 0] = colors[color_name][0]  # Color the detected regions where mask is greater than 0

    cv2_imshow(img) # Use cv2_imshow instead of cv2.imshow to display processed image.

import os
image_path = '/content/Dandelion-(Yellow)-2/train/images'  # Path to your image directory
for filename in os.listdir(image_path):
    if filename.endswith(('.jpg', '.png', '.jpeg')):  # Filter for image files
        img_path = os.path.join(image_path, filename)  # Create the full image path
        detect_colors(img_path, overlap=True)  # With overlapping
        #detect_colors(img_path, overlap=False)  # Without overlapping

"""Code to display bounding box:"""

for filename in os.listdir(image_path):
    if filename.endswith(('.jpg', '.png', '.jpeg')):  # Filter for image files
        img_path = os.path.join(image_path, filename)  # Create the full image path
        draw_boxes(img_path, overlap=True)  # With overlapping

import cv2
from google.colab.patches import cv2_imshow

def draw_boxes(image_path, overlap=True):
  image = cv2.imread('image_path')

  # Coordinates (x, y, width, height)

  for result in results:
    if result.boxes is not None:
      for i in range(len(results[0].boxes.xywh)):
        x, y, w, h = (int)(results[0].boxes.xywh[i,0]),(int)(results[0].boxes.xywh[i,1]),(int)(results[0].boxes.xywh[i,2]),(int)(results[0].boxes.xywh[i,3])
        x1 = x - w // 2
        y1 = y - h // 2
        x2 = x + w // 2
        y2 = y + h // 2
        cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)
  # Draw the bounding box on the image (color in BGR, thickness of the box)
  #cv2.rectangle(image, (x - (int)(w/2), y- (int)(h/2)), (x + - (int)(w/2), y + - (int)(h/2)), (0, 255, 0), 2)
  # Save or display the image with bounding box
  cv2_imshow(image)
  #cv2.waitKey(0)  # Wait for any key to close the window
  #cv2.destroyAllWindows()

  # Optionally, save the image with bounding box
  cv2.imwrite('im_with_box.jpg', image)